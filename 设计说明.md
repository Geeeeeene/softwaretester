# HomemadeTester 项目设计说明

## 1. 项目概述

### 1.1 项目简介

HomemadeTester 是一个基于 **Test IR（测试中间表示）** 的统一测试平台，旨在通过标准化的测试描述格式，整合多种测试工具和执行器，提供一站式的测试管理和执行解决方案。

### 1.2 核心价值

- **统一接口**：通过 Test IR 标准化不同测试类型的描述格式
- **工具整合**：集成多种测试工具（Spix、UTBot、Cppcheck、Clazy、GammaRay 等）
- **异步执行**：基于 Redis Queue 的异步任务处理，支持并发执行
- **可视化界面**：现代化的 React 前端，提供直观的测试管理和结果展示
- **可扩展性**：插件化的执行器架构，易于添加新的测试工具

### 1.3 技术栈

#### 后端技术栈
- **Web框架**：FastAPI 0.104+
- **数据库**：PostgreSQL 15（关系型数据）、Neo4j 5（图数据，可选）
- **任务队列**：Redis 7 + RQ（Redis Queue）
- **ORM**：SQLAlchemy 2.0
- **数据验证**：Pydantic 2.5
- **认证**：JWT Token（规划中）

#### 前端技术栈
- **框架**：React 18 + TypeScript
- **构建工具**：Vite 5
- **路由**：React Router 6
- **状态管理**：TanStack Query（服务器状态）
- **UI组件库**：TailwindCSS + shadcn/ui
- **HTTP客户端**：Axios
- **代码高亮**：react-syntax-highlighter

#### 基础设施
- **容器化**：Docker + Docker Compose
- **存储**：本地文件系统（可扩展至 MinIO）

### 1.4 功能实现状态与计划

HomemadeTester 平台计划支持四种核心测试功能，当前实现状态如下：

#### 1.4.1 静态分析功能 ✅ 已完成

**实现状态**：✅ **已完成**

**已实现内容**：
- ✅ 后端 API 完整实现（`static_analysis.py`）
- ✅ 静态分析服务层（`StaticAnalysisService`）
- ✅ 支持 Cppcheck 和 Clazy 工具集成
- ✅ LLM Agent 增强分析功能
- ✅ 分析结果存储和查询
- ✅ 项目文件树浏览和文件内容查看
- ✅ 前端完整界面（`StaticAnalysisPage.tsx`）
- ✅ 实时状态轮询和结果展示

**技术实现**：
- 后端：FastAPI 端点、服务层、存储层
- 工具集成：Cppcheck、Clazy 命令行调用
- 前端：React 组件、状态管理、文件树展示

#### 1.4.2 UI 测试功能 🚧 前端已完成，后端待实现

**实现状态**：🚧 **前端已完成，后端待实现**

**已完成内容**：
- ✅ Test IR Schema 定义（`UITestIR`）
- ✅ 前端测试用例编辑界面
- ✅ 前端测试执行页面
- ✅ 前端结果展示组件

**待实现内容**：
- ⏳ 后端 API 端点（`/api/v1/projects/{id}/ui-tests/run`）
- ⏳ UI 执行器实现（`UIExecutor`）
- ⏳ Spix 工具集成和适配
- ⏳ 测试执行任务队列集成
- ⏳ 截图和日志收集
- ⏳ 测试结果持久化存储

**实现计划**：
1. **阶段一：后端 API 开发**
   - 创建 UI 测试 API 端点
   - 实现测试用例 CRUD 操作
   - 实现测试执行接口

2. **阶段二：执行器开发**
   - 实现 `UIExecutor` 类
   - 集成 Spix RPC 调用
   - 实现 Test IR 到 Spix 脚本的转换

3. **阶段三：任务执行**
   - 集成 Redis Queue
   - 实现异步任务处理
   - 实现状态更新和结果收集

4. **阶段四：结果处理**
   - 截图保存和管理
   - 执行日志收集
   - 测试结果存储和查询

#### 1.4.3 单元测试功能 🚧 前端已完成，后端待实现

**实现状态**：🚧 **前端已完成，后端待实现**

**已完成内容**：
- ✅ Test IR Schema 定义（`UnitTestIR`）
- ✅ 前端测试用例编辑界面
- ✅ 前端测试执行页面
- ✅ 前端覆盖率报告展示组件

**待实现内容**：
- ⏳ 后端 API 端点（`/api/v1/projects/{id}/unit-tests/run`）
- ⏳ 单元测试执行器实现（`UnitExecutor`）
- ⏳ UTBot Cpp 工具集成
- ⏳ 测试用例生成和执行
- ⏳ 覆盖率数据收集和报告生成
- ⏳ 测试结果持久化存储

**实现计划**：
1. **阶段一：后端 API 开发**
   - 创建单元测试 API 端点
   - 实现测试用例管理接口
   - 实现测试执行接口

2. **阶段二：执行器开发**
   - 实现 `UnitExecutor` 类
   - 集成 UTBot Cpp 工具
   - 实现 Test IR 到 UTBot 配置的转换
   - 实现测试用例自动生成

3. **阶段三：覆盖率收集**
   - 集成覆盖率收集工具（如 Gcov）
   - 实现覆盖率数据解析
   - 生成覆盖率报告（HTML/JSON）

4. **阶段四：结果处理**
   - 测试结果存储
   - 覆盖率数据可视化
   - 历史数据对比

#### 1.4.4 集成测试功能 🚧 前端已完成，后端待实现

**实现状态**：🚧 **前端已完成，后端待实现**

**已完成内容**：
- ✅ Test IR Schema 定义（`IntegrationTestIR`）
- ✅ 前端测试用例编辑界面
- ✅ 前端测试执行页面
- ✅ 前端结果展示组件

**待实现内容**：
- ⏳ 后端 API 端点（`/api/v1/projects/{id}/integration-tests/run`）
- ⏳ 集成测试执行器实现
- ⏳ HTTP 客户端集成（用于 API 测试）
- ⏳ 服务端点测试框架
- ⏳ 测试结果验证和断言
- ⏳ 测试结果持久化存储

**实现计划**：
1. **阶段一：后端 API 开发**
   - 创建集成测试 API 端点
   - 实现测试用例管理接口
   - 实现测试执行接口

2. **阶段二：执行器开发**
   - 实现集成测试执行器类
   - 集成 HTTP 客户端（如 `httpx` 或 `requests`）
   - 实现 Test IR 到 HTTP 请求的转换
   - 实现请求链和依赖管理

3. **阶段三：验证和断言**
   - 实现响应验证逻辑
   - 支持多种断言类型（equals、contains、status code 等）
   - 实现测试数据管理

4. **阶段四：结果处理**
   - 请求/响应日志记录
   - 测试结果存储
   - 性能指标收集（响应时间、吞吐量等）

#### 1.4.5 功能实现路线图

```
阶段一：静态分析 ✅
├── 后端 API 实现 ✅
├── 工具集成 ✅
├── 前端界面 ✅
└── LLM 增强 ✅

阶段二：UI 测试 🚧
├── 后端 API 开发 ⏳
├── Spix 集成 ⏳
├── 执行器实现 ⏳
└── 结果收集 ⏳

阶段三：单元测试 🚧
├── 后端 API 开发 ⏳
├── UTBot 集成 ⏳
├── 覆盖率收集 ⏳
└── 报告生成 ⏳

阶段四：集成测试 🚧
├── 后端 API 开发 ⏳
├── HTTP 客户端集成 ⏳
├── 验证框架 ⏳
└── 性能监控 ⏳
```

#### 1.4.6 技术债务与优先级

**高优先级**（核心功能）：
1. UI 测试后端实现（依赖 Spix 工具）
2. 单元测试后端实现（依赖 UTBot 工具）
3. 集成测试后端实现（相对独立，可快速实现）

**中优先级**（功能增强）：
1. 实时状态推送（WebSocket）
2. 测试结果对比和历史分析
3. 批量测试执行

**低优先级**（优化和扩展）：
1. 更多工具集成
2. AI 辅助测试生成
3. 性能优化

## 2. 系统架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────┐
│          Web UI (React)                 │
│  - 项目管理                              │
│  - 测试用例编辑（Test IR）               │
│  - 测试执行监控                          │
│  - 结果可视化                            │
└────────────┬────────────────────────────┘
             │ HTTP/WebSocket
┌────────────▼────────────────────────────┐
│     Backend API (FastAPI)               │
│  - REST API                             │
│  - Test IR 验证                         │
│  - 文件上传管理                          │
│  - 权限认证（规划中）                    │
└────────────┬────────────────────────────┘
             │
     ┌───────┴───────┐
     ▼               ▼
┌─────────┐    ┌──────────────┐
│ Database│    │ Task Queue   │
│(Postgres│    │  (Redis+RQ)  │
│  SQLite)│    └──────┬───────┘
└─────────┘           │
                      ▼
            ┌──────────────────┐
            │   Worker Pool    │
            │  - 任务调度       │
            │  - 并发控制       │
            └────────┬─────────┘
                     │
         ┌───────────┴───────────┐
         ▼                       ▼
┌─────────────────┐    ┌──────────────────┐
│ Executor Layer  │    │  Static Analysis │
│ - UI Executor   │    │  - Cppcheck      │
│ - Unit Executor │    │  - Clazy         │
│ - Memory Executor│   │  - LLM Agent     │
└─────────────────┘    └──────────────────┘
         │
         ▼
┌─────────────────────┐
│ Artifact Storage    │
│ - Logs              │
│ - Screenshots       │
│ - Coverage Reports  │
│ - Analysis Results  │
└─────────────────────┘
```

### 2.2 分层架构

#### 2.2.1 表现层（Presentation Layer）

表现层是系统与用户交互的界面层，负责接收用户请求并展示处理结果。该层由两部分组成：前端应用和 API 网关。前端应用采用 React 构建的单页应用（SPA），提供现代化的用户界面，包括项目管理、测试用例编辑、测试执行监控和结果可视化等功能。用户通过浏览器与前端应用交互，前端应用通过 HTTP 请求与后端 API 通信。API 网关由 FastAPI 框架实现，作为后端服务的入口，负责路由分发、请求验证和响应格式化。FastAPI 的路由层接收来自前端的 HTTP 请求，根据请求路径将请求分发到相应的 API 端点进行处理。

#### 2.2.2 业务逻辑层（Business Logic Layer）

业务逻辑层是系统的核心处理层，负责实现具体的业务功能和规则。该层主要包括 API 端点、服务层和 Test IR 验证模块。API 端点位于 `backend/app/api/v1/endpoints/` 目录下，按功能模块组织，每个端点负责处理特定类型的业务请求，包括参数验证、业务逻辑调用和响应构建。服务层封装了核心业务逻辑，例如 `StaticAnalysisService` 负责静态分析相关的业务处理，包括调用分析工具、处理分析结果、管理分析状态等。Test IR 验证模块使用 Pydantic 框架对测试用例的 Test IR 格式进行验证，确保测试用例符合预定义的 Schema 规范，保证数据的正确性和一致性。

#### 2.2.3 数据访问层（Data Access Layer）

数据访问层负责管理系统与数据存储之间的交互，提供统一的数据访问接口。该层使用 SQLAlchemy ORM 框架进行数据库操作，通过定义数据模型（Model）来映射数据库表结构，实现面向对象的数据访问方式。ORM 模型位于 `backend/app/db/models/` 目录下，定义了项目、测试用例、测试执行、测试结果等核心实体。数据库会话管理模块负责维护数据库连接池，管理数据库连接的创建、复用和释放，确保连接的高效使用。事务控制机制保证数据操作的一致性，支持事务的提交和回滚。此外，该层还包含存储服务模块，负责文件系统的操作，包括项目文件的上传、静态分析结果的存储、测试日志和截图等文件的保存和管理。

#### 2.2.4 执行层（Execution Layer）

执行层是系统执行测试任务的核心层，负责将抽象的 Test IR 转换为具体的测试工具命令并执行。该层主要包括执行器适配器、Worker 进程和工具集成模块。执行器适配器采用适配器模式设计，将统一的 Test IR 格式转换为不同测试工具所需的特定格式，例如将 UI Test IR 转换为 Spix RPC 调用，将 Unit Test IR 转换为 UTBot 配置。每个执行器继承自 `BaseExecutor` 基类，实现统一的执行接口，便于扩展和维护。Worker 进程基于 Redis Queue 实现异步任务处理，从任务队列中获取待执行的测试任务，调用相应的执行器执行测试，并将执行结果保存到数据库。Worker 支持多进程并发执行，可以配置多个 Worker 实例以提高系统的并发处理能力。工具集成模块负责与外部测试工具进行交互，包括启动工具进程、传递参数、收集输出结果等，确保系统能够正确调用和集成各种测试工具。

### 2.3 核心设计模式

#### 2.3.1 策略模式（Strategy Pattern）

策略模式在系统中用于实现不同测试类型的执行策略。系统定义了 `BaseExecutor` 抽象基类，该基类规定了所有执行器必须实现的统一接口，包括 `execute()` 方法用于执行测试，以及 `validate_ir()` 方法用于验证 Test IR 格式。具体的执行器类如 `UIExecutor`、`UnitExecutor`、`StaticExecutor` 等继承自 `BaseExecutor`，各自实现不同的测试执行策略。例如，`UIExecutor` 负责执行 UI 自动化测试，`UnitExecutor` 负责执行单元测试，`StaticExecutor` 负责执行静态代码分析。这种设计模式的优势在于系统可以灵活地添加新的执行器类型，而无需修改现有的代码结构。当需要支持新的测试类型时，只需创建一个新的执行器类并实现 `BaseExecutor` 接口，系统就能自动支持该新的测试类型，实现了开闭原则（对扩展开放，对修改关闭）。

#### 2.3.2 工厂模式（Factory Pattern）

工厂模式用于统一管理执行器对象的创建过程。系统实现了 `ExecutorFactory` 工厂类，该类维护了一个执行器类型到执行器类的映射表。当系统需要执行某个测试任务时，会根据测试类型（如 UI、Unit、Static 等）调用工厂类的 `get_executor()` 方法，工厂类根据测试类型从映射表中查找对应的执行器类，并创建相应的执行器实例返回。这种设计模式的优势在于将对象创建的逻辑集中管理，客户端代码不需要直接实例化具体的执行器类，只需要知道测试类型即可获取相应的执行器。这种解耦设计使得系统更加灵活，如果将来需要修改执行器的创建逻辑或添加新的执行器类型，只需要修改工厂类，而不影响使用执行器的其他代码。同时，工厂模式也便于进行单元测试，可以通过模拟工厂来测试不同的执行器行为。

#### 2.3.3 适配器模式（Adapter Pattern）

适配器模式在系统中用于将统一的 Test IR 格式转换为不同测试工具所需的特定格式。由于系统集成了多种测试工具，每种工具都有自己独特的输入格式和调用方式，适配器模式提供了一个统一的转换层，使得系统能够以一致的方式与不同的测试工具交互。例如，`spix_adapter.py` 适配器负责将 UI Test IR 转换为 Spix 工具所需的 RPC 调用格式，`utbot_adapter.py` 适配器负责将 Unit Test IR 转换为 UTBot Cpp 工具的配置格式，`static_analyzer.py` 适配器负责将 Static Test IR 转换为 Cppcheck 或 Clazy 工具的命令行参数。每个适配器都封装了与特定工具交互的细节，包括参数转换、工具调用、结果解析等。这种设计使得系统能够轻松集成新的测试工具，只需要实现相应的适配器即可，而无需修改系统的核心逻辑。适配器模式实现了系统与外部工具之间的解耦，提高了系统的可维护性和可扩展性。

## 3. 核心模块设计

### 3.1 Test IR（测试中间表示）

#### 3.1.1 设计理念

Test IR 是项目的核心抽象，通过统一的 JSON/YAML 格式描述所有测试类型，实现：
- **工具无关性**：测试用例不依赖具体工具
- **可复用性**：同一测试用例可在不同工具间迁移
- **可维护性**：标准化的格式便于版本管理和协作

#### 3.1.2 IR 类型定义

##### UI 测试 IR
```json
{
  "type": "ui",
  "name": "登录测试",
  "description": "验证用户登录功能",
  "steps": [
    {"type": "input", "target": "username", "value": "admin"},
    {"type": "input", "target": "password", "value": "123456"},
    {"type": "click", "target": "loginButton"},
    {"type": "assert", "target": "welcome", "value": "欢迎"}
  ],
  "priority": "high"
}
```

##### 单元测试 IR
```json
{
  "type": "unit",
  "name": "测试加法函数",
  "function_under_test": {
    "name": "add",
    "file_path": "math_utils.cpp"
  },
  "inputs": {
    "parameters": {"a": 1, "b": 2}
  },
  "assertions": [
    {"type": "equals", "expected": 3}
  ]
}
```

##### 静态分析 IR
```json
{
  "type": "static",
  "name": "代码质量检查",
  "tool": "cppcheck",
  "target_files": ["src/**/*.cpp"],
  "rules": [
    {"rule_id": "mem-leak", "severity": "error"}
  ],
  "enable": "all"
}
```

#### 3.1.3 IR Schema 定义

使用 Pydantic 定义 IR Schema，提供：
- **类型验证**：自动验证数据类型
- **必填字段检查**：确保必要字段存在
- **默认值处理**：为可选字段提供默认值
- **文档生成**：自动生成 API 文档

### 3.2 执行器模块

#### 3.2.1 执行器基类

```python
class BaseExecutor(ABC):
    @abstractmethod
    async def execute(self, test_ir: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """执行测试"""
        pass
    
    @abstractmethod
    async def validate_ir(self, test_ir: Dict[str, Any]) -> bool:
        """验证Test IR格式"""
        pass
```

#### 3.2.2 具体执行器

##### 静态分析执行器（StaticExecutor）✅ 已实现
- **状态**：✅ **已完成实现**
- **工具**：Cppcheck、Clazy
- **功能**：执行静态代码分析，检测代码质量问题
- **适配**：将 Static Test IR 转换为工具命令行参数
- **实现位置**：`backend/app/static_analysis/service.py`
- **API 端点**：`/api/v1/projects/{id}/static-analysis/*`

##### UI 执行器（UIExecutor）⏳ 计划实现
- **状态**：⏳ **前端已完成，后端待实现**
- **工具**：Spix（Qt 应用测试框架）
- **功能**：执行 UI 自动化测试，支持点击、输入、断言等操作
- **适配**：将 UI Test IR 转换为 Spix RPC 调用
- **计划实现**：
  - 后端 API 端点开发
  - Spix 工具集成和适配
  - Test IR 到 Spix 脚本转换
  - 截图和日志收集

##### 单元测试执行器（UnitExecutor）⏳ 计划实现
- **状态**：⏳ **前端已完成，后端待实现**
- **工具**：UTBot Cpp（单元测试生成工具）
- **功能**：生成并执行单元测试，收集覆盖率数据
- **适配**：将 Unit Test IR 转换为 UTBot 配置
- **计划实现**：
  - 后端 API 端点开发
  - UTBot Cpp 工具集成
  - 测试用例自动生成
  - 覆盖率数据收集和报告生成

##### 集成测试执行器（IntegrationExecutor）⏳ 计划实现
- **状态**：⏳ **前端已完成，后端待实现**
- **工具**：HTTP 客户端（httpx/requests）
- **功能**：执行 API 集成测试，验证服务端点
- **适配**：将 Integration Test IR 转换为 HTTP 请求
- **计划实现**：
  - 后端 API 端点开发
  - HTTP 客户端集成
  - 请求链和依赖管理
  - 响应验证和断言

##### 内存检测执行器（MemoryExecutor）⏳ 计划实现
- **状态**：⏳ **规划中**
- **工具**：GammaRay（内存分析工具）
- **功能**：检测内存泄漏、未初始化变量等问题
- **适配**：将 Memory Test IR 转换为 GammaRay 配置
- **优先级**：低优先级，待核心功能完成后实现

#### 3.2.3 执行器工厂

```python
class ExecutorFactory:
    _executors = {
        TestType.UI: UIExecutor,
        TestType.UNIT: UnitExecutor,
        TestType.STATIC: StaticExecutor,
        TestType.MEMORY: MemoryExecutor,
    }
    
    @classmethod
    def get_executor(cls, test_type: TestType) -> BaseExecutor:
        """根据测试类型获取执行器实例"""
        return cls._executors[test_type]()
```

### 3.3 任务队列系统

#### 3.3.1 技术选型

- **队列系统**：Redis + RQ（Redis Queue）
- **优势**：
  - 轻量级，易于部署
  - 支持任务优先级
  - 提供任务状态跟踪
  - 支持任务重试

#### 3.3.2 任务流程

```
1. API接收执行请求
   ↓
2. 创建TestExecution记录（状态=pending）
   ↓
3. 将任务推入Redis队列
   ↓
4. Worker进程拾取任务
   ↓
5. 更新状态为running
   ↓
6. 调用ExecutorFactory获取执行器
   ↓
7. 执行器执行测试
   ↓
8. 保存TestResult到数据库
   ↓
9. 更新TestExecution状态为completed/failed
   ↓
10. 前端轮询获取状态更新
```

#### 3.3.3 Worker 配置

- **并发数**：可配置多个 Worker 进程
- **队列优先级**：支持 high、default、low 三级优先级
- **超时控制**：任务执行超时自动取消
- **错误处理**：失败任务记录错误日志

### 3.4 数据库设计

#### 3.4.1 核心数据模型

##### 项目模型（Project）
```python
class Project(Base):
    id: int
    name: str
    description: str
    project_type: str  # ui, unit, static, memory
    source_path: str   # 源代码路径
    build_path: str    # 构建输出路径
    binary_path: str   # 二进制文件路径
    language: str      # cpp, python, java等
    framework: str     # Qt, GTK等
    is_active: bool
    created_at: datetime
    updated_at: datetime
```

##### 测试用例模型（TestCase）
```python
class TestCase(Base):
    id: int
    project_id: int
    name: str
    test_type: str
    test_ir: JSONB     # Test IR内容（JSON格式）
    created_at: datetime
    updated_at: datetime
```

##### 测试执行模型（TestExecution）
```python
class TestExecution(Base):
    id: int
    project_id: int
    executor_type: str
    status: str        # pending, running, completed, failed
    started_at: datetime
    completed_at: datetime
    error_message: str
```

##### 测试结果模型（TestResult）
```python
class TestResult(Base):
    id: int
    execution_id: int
    test_case_id: int
    status: str        # passed, failed, error, skipped
    duration_seconds: float
    error_message: str
    coverage_data: JSONB
    artifacts: JSONB  # 日志、截图等文件路径
```

##### 静态分析模型（StaticAnalysis）
```python
class StaticAnalysis(Base):
    id: int
    project_id: int
    tool: str         # cppcheck, clazy
    status: str
    results: JSONB    # 分析结果
    timestamp: int     # 时间戳
    created_at: datetime
```

#### 3.4.2 关系设计

- **Project 1:N TestCase**：一个项目包含多个测试用例
- **Project 1:N TestExecution**：一个项目有多次执行记录
- **Project 1:N StaticAnalysis**：一个项目有多次静态分析记录
- **TestExecution 1:N TestResult**：一次执行产生多个测试结果

### 3.5 静态分析模块

#### 3.5.1 功能特性

- **多工具支持**：集成 Cppcheck、Clazy 等静态分析工具
- **LLM 增强**：使用大语言模型分析代码，提供更智能的问题诊断
- **结果存储**：分析结果持久化存储，支持历史对比
- **文件浏览**：支持查看项目文件树和文件内容

#### 3.5.2 核心服务

##### StaticAnalysisService
- `run_analysis()`：执行静态分析
- `get_analysis_status()`：获取分析状态
- `get_analysis_results()`：获取分析结果
- `get_file_tree()`：获取项目文件树
- `get_file_content()`：获取文件内容

#### 3.5.3 LLM Agent 集成

- **代码理解**：使用 LLM 理解代码语义
- **问题诊断**：结合静态分析工具结果，提供更详细的问题说明
- **修复建议**：生成代码修复建议

### 3.6 前端架构

#### 3.6.1 页面结构

```
/                      - 首页（项目概览）
/projects              - 项目列表
/projects/:id          - 项目详情
  ├── /test-cases     - 测试用例管理
  ├── /executions      - 测试执行记录
  ├── /static-analysis - 静态分析
  └── /results         - 结果分析
```

#### 3.6.2 组件设计

##### 布局组件
- `Layout`：应用主布局，包含导航栏和侧边栏
- `Header`：顶部导航栏
- `Sidebar`：侧边导航菜单

##### 页面组件
- `ProjectsPage`：项目列表页面
- `ProjectDetailPage`：项目详情页面
- `TestCasesPage`：测试用例管理页面
- `TestExecutionPage`：测试执行页面
- `StaticAnalysisPage`：静态分析页面
- `ResultsPage`：结果分析页面

##### UI 组件
- 基于 shadcn/ui 的组件库
- `Button`、`Card`、`Dialog`、`Select`、`Tabs` 等

#### 3.6.3 状态管理

##### 服务器状态（TanStack Query）
```typescript
// 查询项目列表
const { data: projects } = useQuery({
  queryKey: ['projects'],
  queryFn: () => projectsApi.list()
})

// 创建项目
const createProject = useMutation({
  mutationFn: projectsApi.create,
  onSuccess: () => {
    queryClient.invalidateQueries(['projects'])
  }
})
```

##### 本地状态（React Hooks）
- `useState`：组件内部状态
- `useContext`：全局共享状态（如用户信息）

## 4. 关键流程设计

### 4.1 测试执行流程

```
用户操作
  ↓
前端发送 POST /api/v1/executions
  ↓
Backend 验证请求
  ↓
创建 TestExecution 记录（status=pending）
  ↓
将任务推入 Redis 队列
  ↓
返回 execution_id 给前端
  ↓
Worker 拾取任务
  ↓
更新状态为 running
  ↓
调用 ExecutorFactory.get_executor()
  ↓
执行器执行测试
  ├── 转换 Test IR 为工具格式
  ├── 调用外部工具
  ├── 收集执行结果
  └── 生成覆盖率报告（如适用）
  ↓
保存 TestResult 到数据库
  ↓
更新 TestExecution 状态为 completed/failed
  ↓
前端轮询/WebSocket 获取状态更新
  ↓
显示结果给用户
```

### 4.2 Test IR 编辑流程

```
用户进入用例编辑器
  ↓
选择测试类型（UI/Unit/Static/Memory）
  ↓
加载对应 IR Schema
  ↓
提供 JSON/YAML 双模式编辑
  ↓
实时 Schema 验证（前端 Pydantic/Zod）
  ↓
用户保存
  ↓
后端二次验证（Pydantic）
  ↓
存储到数据库（JSONB 字段）
  ↓
返回成功响应
```

### 4.3 静态分析流程

```
用户触发静态分析
  ↓
前端发送 POST /api/v1/projects/{id}/static-analysis/run
  ↓
Backend 验证项目存在且已上传源代码
  ↓
创建后台任务
  ↓
StaticAnalysisService.run_analysis()
  ├── 调用静态分析工具（Cppcheck/Clazy）
  ├── 解析工具输出
  ├── （可选）调用 LLM Agent 增强分析
  └── 保存结果到数据库
  ↓
前端轮询状态
  ↓
获取分析结果并展示
```

### 4.4 文件上传流程

```
用户选择文件
  ↓
前端发送 POST /api/v1/upload
  ↓
Backend 接收文件
  ├── 验证文件类型和大小
  ├── 保存到 artifacts/uploads/
  └── 更新 Project.source_path
  ↓
返回文件路径
  ↓
前端更新项目信息
```

## 5. 扩展性设计

### 5.1 添加新执行器

1. **创建执行器类**
   ```python
   class NewExecutor(BaseExecutor):
       async def execute(self, test_ir, config):
           # 实现执行逻辑
           pass
       
       async def validate_ir(self, test_ir):
           # 实现验证逻辑
           pass
   ```

2. **注册到工厂**
   ```python
   ExecutorFactory.register_executor(TestType.NEW, NewExecutor)
   ```

3. **无需修改其他代码**：系统自动支持新执行器

### 5.2 添加新测试类型

1. **定义 IR Schema**
   - 在 `backend/app/test_ir/schemas.py` 添加新的 IR 模型
   - 使用 Pydantic 定义字段和验证规则

2. **创建执行器**
   - 实现对应的执行器类

3. **更新前端**
   - 添加类型定义
   - 创建编辑器模板
   - 添加结果展示组件

### 5.3 水平扩展

- **Worker 扩展**：增加 Worker 进程数，提高并发处理能力
- **数据库分片**：按项目分片，支持大规模数据
- **缓存层**：添加 Redis 缓存，提高查询性能
- **负载均衡**：使用 Nginx 反向代理多个 Backend 实例

## 6. 安全性设计

### 6.1 认证与授权（规划中）

- **JWT Token 认证**：无状态的用户认证
- **RBAC 角色权限控制**：基于角色的访问控制
- **API 速率限制**：防止 API 滥用

### 6.2 数据安全

- **SQL 注入防护**：使用 ORM 参数化查询
- **XSS 防护**：React 自动转义用户输入
- **CSRF Token**：防止跨站请求伪造
- **文件上传验证**：验证文件类型和大小

### 6.3 执行器隔离

- **容器化执行**：使用 Docker 隔离测试执行环境
- **资源限制**：限制 CPU、内存使用
- **超时控制**：任务执行超时自动终止
- **沙箱环境**：限制文件系统访问

## 7. 性能优化

### 7.1 数据库优化

- **索引优化**：为常用查询字段添加索引（project_id、test_type 等）
- **查询优化**：减少 JOIN 操作，使用预加载
- **连接池配置**：合理配置数据库连接池大小
- **定期维护**：定期执行 VACUUM 和 ANALYZE

### 7.2 API 优化

- **分页查询**：列表接口支持分页
- **字段选择**：只返回必要字段，减少数据传输
- **缓存策略**：使用 Redis 缓存热点数据
- **异步处理**：耗时操作异步执行

### 7.3 前端优化

- **代码分割**：使用 React.lazy 实现路由级代码分割
- **虚拟滚动**：长列表使用虚拟滚动
- **图片懒加载**：延迟加载非关键图片
- **CDN 加速**：静态资源使用 CDN

## 8. 部署架构

### 8.1 Docker Compose 部署

```yaml
services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
  
  frontend:
    build: ./frontend
    ports:
      - "5173:5173"
    depends_on:
      - backend
  
  postgres:
    image: postgres:15
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7
    volumes:
      - redis_data:/data
  
  worker:
    build: ./backend
    command: python -m app.worker.worker
    depends_on:
      - postgres
      - redis
```

### 8.2 生产环境建议

- **Web 服务器**：使用 Gunicorn/Uvicorn 多进程运行
- **反向代理**：Nginx 作为反向代理和负载均衡
- **容器编排**：Kubernetes 或 Docker Swarm
- **SSL 证书**：配置 HTTPS
- **监控告警**：集成 Prometheus + Grafana
- **日志聚合**：ELK Stack 或 Loki

## 9. 项目结构

```
softwaretester/
├── backend/                    # 后端服务
│   ├── app/
│   │   ├── api/               # REST API路由
│   │   │   └── v1/
│   │   │       └── endpoints/
│   │   │           ├── projects.py
│   │   │           ├── test_cases.py
│   │   │           ├── executions.py
│   │   │           ├── static_analysis.py
│   │   │           └── upload.py
│   │   ├── core/              # 核心配置
│   │   │   └── config.py
│   │   ├── db/                # 数据库
│   │   │   ├── models/        # SQLAlchemy模型
│   │   │   ├── base.py
│   │   │   └── session.py
│   │   ├── executors/         # 执行器适配层
│   │   │   ├── base_executor.py
│   │   │   ├── ui_executor.py
│   │   │   ├── unit_executor.py
│   │   │   ├── static_executor.py
│   │   │   ├── memory_executor.py
│   │   │   └── executor_factory.py
│   │   ├── static_analysis/   # 静态分析模块
│   │   │   ├── service.py
│   │   │   ├── agent.py
│   │   │   └── storage.py
│   │   ├── test_ir/           # Test IR定义
│   │   │   └── schemas.py
│   │   ├── worker/            # 后台任务
│   │   │   ├── tasks.py
│   │   │   └── worker.py
│   │   └── main.py            # FastAPI应用入口
│   ├── scripts/               # 工具脚本
│   ├── tools/                 # 集成的测试工具
│   │   ├── cppcheck/
│   │   ├── clazy/
│   │   ├── utbot/
│   │   └── gammaray/
│   ├── artifacts/             # 存储目录
│   │   ├── projects/          # 项目文件
│   │   ├── static_analysis/   # 静态分析结果
│   │   └── uploads/           # 上传文件
│   ├── requirements.txt
│   └── Dockerfile
│
├── frontend/                  # React前端
│   ├── src/
│   │   ├── components/       # React组件
│   │   ├── pages/           # 页面组件
│   │   ├── lib/             # 工具库
│   │   │   ├── api.ts       # API客户端
│   │   │   └── utils.ts
│   │   ├── App.tsx
│   │   └── main.tsx
│   ├── package.json
│   └── Dockerfile
│
├── docker-compose.yml        # Docker编排配置
├── README.md                 # 项目文档
├── ARCHITECTURE.md           # 架构文档
├── PROJECT_STRUCTURE.md       # 结构说明
└── 设计说明.md               # 本文件
```

## 10. 开发指南

### 10.1 环境搭建

1. **安装依赖**
   ```bash
   # 后端
   cd backend
   pip install -r requirements.txt
   
   # 前端
   cd frontend
   npm install
   ```

2. **配置环境变量**
   - 复制 `.env.example` 为 `.env`
   - 配置数据库连接、Redis 连接等

3. **初始化数据库**
   ```bash
   python backend/scripts/init_db.py
   ```

### 10.2 开发流程

1. **后端开发**
   - 使用虚拟环境
   - 启动开发服务器：`uvicorn app.main:app --reload`
   - 编写单元测试：`pytest`

2. **前端开发**
   - 启动开发服务器：`npm run dev`
   - Vite HMR 自动刷新
   - 使用 TypeScript 确保类型安全

3. **测试执行器开发**
   - 继承 `BaseExecutor`
   - 实现 `execute()` 和 `validate_ir()` 方法
   - 在 `ExecutorFactory` 注册

### 10.3 代码规范

- **Python**：遵循 PEP 8，使用 Black 格式化
- **TypeScript**：遵循 ESLint 规则
- **提交信息**：使用清晰的提交信息，遵循 Conventional Commits

## 11. 未来规划

### 11.1 核心功能完善（短期计划）

#### 11.1.1 UI 测试功能实现
- **后端 API 开发**：完成 UI 测试相关的 REST API 端点
- **Spix 集成**：实现 Spix 工具适配器，支持 Qt 应用测试
- **执行器实现**：完成 `UIExecutor` 类，实现 Test IR 到 Spix 脚本的转换
- **结果收集**：实现截图保存、日志收集和测试结果存储

#### 11.1.2 单元测试功能实现
- **后端 API 开发**：完成单元测试相关的 REST API 端点
- **UTBot 集成**：实现 UTBot Cpp 工具适配器
- **覆盖率收集**：集成覆盖率工具，实现覆盖率数据收集和报告生成
- **测试生成**：支持基于 Test IR 自动生成单元测试用例

#### 11.1.3 集成测试功能实现
- **后端 API 开发**：完成集成测试相关的 REST API 端点
- **HTTP 客户端集成**：实现 HTTP 请求执行和响应处理
- **验证框架**：实现多种断言类型和验证逻辑
- **性能监控**：收集响应时间、吞吐量等性能指标

### 11.2 功能增强（中期计划）

- **实时推送**：WebSocket 实时推送测试执行状态，替代轮询机制
- **权限系统**：完整的用户认证和权限管理（JWT Token、RBAC）
- **测试结果对比**：支持历史测试结果对比和趋势分析
- **批量执行**：支持批量测试用例执行和并行处理
- **CI/CD 集成**：与 Jenkins、GitLab CI、GitHub Actions 等集成

### 11.3 工具扩展（长期计划）

- **更多执行器**：Selenium、Playwright（Web UI 测试）、JUnit（Java 单元测试）等
- **性能测试**：集成性能测试工具（如 JMeter、Locust）
- **安全扫描**：集成安全漏洞扫描工具（如 OWASP ZAP）
- **内存检测**：完善 GammaRay 集成，实现内存泄漏检测

### 11.4 AI 辅助功能

- **AI 生成测试用例**：基于代码自动生成测试用例
- **智能问题诊断**：使用 LLM 分析测试失败原因
- **代码修复建议**：基于静态分析结果生成修复建议
- **测试优化建议**：分析测试覆盖率，提出优化建议

### 11.5 架构优化

- **微服务化**：将不同模块拆分为独立服务，提高可扩展性
- **分布式调度**：支持分布式任务调度，提高并发处理能力
- **图数据库集成**：完善 Neo4j 集成，支持 CFG（控制流图）可视化
- **缓存优化**：实现多级缓存策略，提高查询性能

## 12. 总结

HomemadeTester 通过 Test IR 统一接口、执行器适配层、异步任务队列等设计，实现了一个可扩展、易维护的统一测试平台。项目采用现代化的技术栈，提供友好的用户界面，支持多种测试类型和工具，为软件测试提供了完整的解决方案。

---

**文档版本**：v1.0  
**最后更新**：2024年  
**维护者**：HomemadeTester 开发团队

